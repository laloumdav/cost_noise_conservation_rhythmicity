#!/usr/bin/env python
"""
Created 2014-04-09
Author: Alan L. Hutchison, alanlhutchison@uchicago.edu, Aaron Dinner Group, University of Chicago
This script takes a jtkout file (generated by jtk7.py), a corresponding permutation p-value list for the performed tests (generated by make_permutations.sh and ending in *permutation_01-20_jtkout.best_ps.txt) and threshold field and value information.
The threshold field is a field found in the header of the *jtkout.txt file such as "Mean", or "FC". The script will then exclude all genes/time series in that file with a value for the field below the value you provide as the last argument (thresh).
It outputs  a file with 1 step BH-correction performed after identifying the best P value and comparing it with the emprical ones.

    fn= sys.argv[1] # Name of JTK file you wish to have analyzed
    fn_ps = sys.argv[2] # Name of empP file to be referenced against
    field = sys.argv[3] # JTK output field to threshold against
    thresh = sys.argv[4] # Threshold value to use for data. 2 for tpm data
"""

import statsmodels.stats.multitest as ssm
from operator import itemgetter
import sys
import time
import numpy as np

def main():
    fn= sys.argv[1] # Name of JTK file you wish to have analyzed
    fn_ps = sys.argv[2] # Name of empP file to be referenced against
    field = sys.argv[3] # JTK output field to threshold against
    thresh = sys.argv[4] # Threshold value to use for data. 2 for tpm data
    print fn
    data,header= read_in(fn)
    Ps = read_in_Ps(fn_ps)
    indx = header.index(field)
    master = sort_name(data)
    master = edge_case(header,master)
    #print 'sorted'
    master,seen = best_P(master,Ps)
    #print 'best_p'
    master = BH_correct(master,indx,thresh)
    #print 'bh_corrected'
    fn_out_temp = fn.split("/")[-1]
    fn_out = "_".join(fn_out_temp.split(".")[0:-1])+"_{0}_lt{1}_min_empP.txt".format(field,thresh)
    write_out_1step(master,header,fn_out)

def read_in(fn):
    data = []
    with open(fn,'r') as f:
        for line in f:
            words = line.strip().split()
            if words[0]=="ID" or words[0]=="#ID":
                header=words
            else:
                if words[-1]=="nan":
                    words[-1] = "1"
                data.append(words)
    return data,header

def get_name_set(data):
    names = []
    for item in data:
        names.append(item[0])
    names = set(names)
    return names

def sort_name(data):
    good = []
    bad = []
    for line in data:
        if line[-1]==-10000:
            bad.append(line)
        else:
            line = [float(num) if is_number(num) else num for num in line]
            good.append(line)
    good = sorted(good,key= itemgetter(-1,0))
    data= good + bad
    return data

def edge_case(header,sorted_data):
    ### This will distinguish between ties
    phind = header.index('Phase')
    asymind = header.index('Asymmetry')
    maxind = header.index('MaxLoc')
    minind = header.index('MinLoc')
    keep = []
    delete = []
    for i in xrange(1,len((sorted_data))):
        dat = sorted_data[i]
        datmin1 = sorted_data[i-1]
        if dat[0]==datmin1[0] and dat[-1]==datmin1[-1]:
            zero =np.abs(float(dat[phind])-(float(dat[maxind][2:]) % 24))
            one = np.abs(float(datmin1[phind])-(float(datmin1[maxind][2:])%24))
            print dat[0]
            print zero,dat
            print one,datmin1
            if zero>one:
                keep.append(i-1)
                delete.append(i)
            elif zero<one:
                keep.append(i)
                delete.append(i-1)
            elif zero==one:
                zero=np.abs( float(dat[phind])  + float(dat[asymind]) - (float(dat[minind][2:])%24) )
                one =np.abs( float(datmin1[phind])  + float(datmin1[asymind]) - (float(datmin1[minind][2:])%24) )
                if zero>one:
                    keep.append(i-1)
                    delete.append(i)
                elif zero<one:
                    keep.append(i)
                    delete.append(i)
                elif zero==one:
                    print 'There is a tie for',dat,datmin1
                    keep.append(i)
                    delete.append(i-1)
        else:
            keep.append(i)
    new_sorted_data = []
    for i in set(keep):
        if i not in delete:
            print sorted_data[i]
            new_sorted_data.append(sorted_data[i])
    return new_sorted_data
            
    
    


def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def best_P(data,Ps):
    # data should already be ordered at this point
    seen=[]
    data_uniq =[]
    for datum in data:
        if datum[0] not in seen:
            seen.append(datum[0])
            P_real=empP(float(datum[-1]),Ps)
            datum.append(P_real)
            data_uniq.append(datum)
    return data_uniq,seen

def read_in_Ps(fn_ps):
    Ps = []
    with open(fn_ps,'r') as f:
        for line in f:
            words = line.split()
            Ps.append(float(words[1]))
    return Ps


def empP(P,Ps):
    less = sum([(emp <=P) for emp in Ps])
    empP = (1.+ less) / (1. + len(Ps))
    return empP

def BH_correct(data,indx,thresh):
    pvals = []
    d_exclude=[]
    names = []
    vals = []
    datums = []
    for lines in data:        
        if float(lines[indx]) > float(thresh):
            datum = lines
            datum = [float(num) if is_number(num) else num for num in datum]
            names.append(lines[0])
            vals.append(float(lines[-1]))
            datums.append(datum)
        else:
            d_exclude.append([lines[0],"-10000"])
    bhs= list(ssm.multipletests(vals,method="fdr_bh")[1])
    for i in xrange(len(bhs)):
        #print datums[i]
        datums[i].append(bhs[i])
        #print datums[i]
    datums = sorted(datums,key=itemgetter(-1,-2))
    datums = datums + d_exclude
    return datums


def write_out_1step(data,header,fn_out):
    new_header = "\t".join(header)+"\tempP\tBH1"
    with open(fn_out,'w') as g:
        g.write(new_header+"\n")
        for datum in data:
            datum = [str(d) for d in datum]
            g.write("\t".join(datum)+"\n")



if __name__=="__main__":
    main()
